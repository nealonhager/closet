import logging
from google import genai
from PIL import Image
from io import BytesIO
from pathlib import Path
from typing import List, Optional
from flask import Flask, request, jsonify, send_file
import os
import uuid
from database import ClosetDatabase


# Initialize Flask app
app = Flask(__name__)
app.config["MAX_CONTENT_LENGTH"] = 16 * 1024 * 1024  # 16MB max file size

# Initialize folders
INPUT_FOLDER = Path("images/input")
OUTPUT_FOLDER = Path("images/output")
ARCHIVE_FOLDER = Path("images/archive")
OUTFITS_FOLDER = Path("images/outfits")

# Initialize database
db = ClosetDatabase()


def assure_folders_exist(*folders: List[Path]) -> None:
    """
    Assure that the folders exist
    """
    for folder in folders:
        folder.mkdir(parents=True, exist_ok=True)


def initialize_app():
    """Initialize the application with existing images."""
    # Ensure folders exist
    assure_folders_exist(INPUT_FOLDER, OUTPUT_FOLDER, ARCHIVE_FOLDER, OUTFITS_FOLDER)

    # Populate database with existing images
    try:
        added_count = db.populate_existing_images(OUTPUT_FOLDER)
        if added_count > 0:
            logging.info(f"Populated database with {added_count} existing images")
        else:
            logging.info("No new images found to populate")
    except Exception as e:
        logging.error(f"Error populating existing images: {e}")


# Initialize the app
initialize_app()


def process_image_with_ai(image_path: Path, article: str) -> Optional[Path]:
    """
    Process a single image with AI to extract the clothing article.

    Args:
        image_path: Path to the input image
        article: Type of clothing article to extract

    Returns:
        Path to the processed image or None if processing failed
    """
    # Check if Google API key is set
    api_key = os.getenv("GEMINI_API_KEY")
    logging.info(f"GEMINI_API_KEY: {api_key}")
    if not api_key:
        print("Error: GEMINI_API_KEY environment variable is not set")
        return None

    try:
        client = genai.Client(api_key=api_key)
        prompt = f"I'm going to send you a picture of a {article}, i want you to remove the rest of the image and only show the {article}. Remove any people, pets, or other objects that are not the {article}. I'm trying to make an app that will show all the things in your closet. If you can't find the article, don't return an image."

        image_prompt = Image.open(image_path)
        response = client.models.generate_content(
            model="gemini-2.5-flash-image-preview", contents=[prompt, image_prompt]
        )

        if not response.candidates or not response.candidates[0].content.parts:
            print("No content generated by AI model")
            return None

        for part in response.candidates[0].content.parts:
            if part.inline_data is not None:
                image = Image.open(BytesIO(part.inline_data.data))
                new_file_name = f"{image_path.stem} - {article}.png"
                output_path = OUTPUT_FOLDER / new_file_name
                image.save(output_path)
                return output_path

        print("No image data found in AI response")
        return None
    except Exception as e:
        print(f"Error processing image {image_path}: {e}")
        return None


def generate_outfit_with_ai(
    image_paths: List[Path], categories: List[str]
) -> Optional[Path]:
    """
    Generate a complete outfit image using Gemini API.

    Args:
        image_paths: List of paths to clothing item images
        categories: List of clothing categories

    Returns:
        Path to the generated outfit image or None if generation failed
    """
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        logging.error("GEMINI_API_KEY environment variable is not set")
        return None

    try:
        client = genai.Client(api_key=api_key)

        # Create a detailed prompt for outfit generation
        clothing_items = ", ".join(categories)
        prompt = f"""I'm going to send you {len(image_paths)} images of individual clothing items: {clothing_items}. 
        
        Please create a single image showing a complete outfit on a 150 lb, 5'10" white male in his mid-20s wearing all these clothing items together. 
        
        The outfit should look stylish and well-coordinated. Make sure the person is wearing all the items in a natural, realistic way. 
        The image should be a full-body shot showing the complete outfit.
        
        If any of the clothing items don't make sense together or can't be worn as a complete outfit, please create the best possible combination and note any issues."""

        # Load all images
        images = []
        for image_path in image_paths:
            if image_path.exists():
                images.append(Image.open(image_path))
            else:
                logging.warning(f"Image not found: {image_path}")

        if not images:
            logging.error("No valid images found for outfit generation")
            return None

        # Generate the outfit
        response = client.models.generate_content(
            model="gemini-2.5-flash-image-preview", contents=[prompt] + images
        )

        if not response.candidates or not response.candidates[0].content.parts:
            logging.error("No content generated by AI model for outfit")
            return None

        for part in response.candidates[0].content.parts:
            if part.inline_data is not None:
                outfit_image = Image.open(BytesIO(part.inline_data.data))
                outfit_filename = f"outfit_{uuid.uuid4()}.png"
                outfit_path = OUTFITS_FOLDER / outfit_filename
                outfit_image.save(outfit_path)
                return outfit_path

        logging.error("No image data found in AI response for outfit")
        return None

    except Exception as e:
        logging.error(f"Error generating outfit: {e}")
        return None


@app.route("/health", methods=["GET"])
def health_check() -> dict:
    """
    Health check endpoint.

    Returns:
        Status information about the API
    """
    return jsonify({"status": "healthy", "message": "Closet API is running"})


@app.route("/process", methods=["POST"])
def process_image() -> dict:
    """
    Process a single uploaded image to extract clothing article.

    Expected form data:
        - file: Image file to process
        - article: Type of clothing article to extract

    Returns:
        JSON response with processing results
    """
    if "file" not in request.files:
        return jsonify({"error": "No file provided"}), 400

    if "article" not in request.form:
        return jsonify({"error": "No article type provided"}), 400

    file = request.files["file"]
    article = request.form["article"]

    if file.filename == "":
        return jsonify({"error": "No file selected"}), 400

    if not file.filename.lower().endswith((".png", ".jpg", ".jpeg")):
        return jsonify(
            {"error": "Invalid file type. Only PNG, JPG, and JPEG are supported"}
        ), 400

    # Ensure folders exist
    assure_folders_exist(INPUT_FOLDER, OUTPUT_FOLDER, ARCHIVE_FOLDER)

    # Save uploaded file temporarily
    filename = f"{uuid.uuid4()}_{file.filename}"
    temp_path = INPUT_FOLDER / filename
    file.save(temp_path)

    try:
        # Process the image
        result_path = process_image_with_ai(temp_path, article)

        if result_path and result_path.exists():
            # Save image to database
            image_id = db.add_image(
                filename=result_path.name,
                file_path=str(result_path),
                description=None,  # Will be manually reviewed later
            )

            # Add category to database and assign to image
            category_id = db.add_category(name=article)
            db.assign_category_to_image(image_id, category_id)

            return jsonify(
                {
                    "success": True,
                    "message": f"Successfully processed {article}",
                    "output_file": result_path.name,
                    "download_url": f"/download/{result_path.name}",
                    "image_url": f"/images/{result_path.name}",
                    "image_id": image_id,
                    "category": article,
                }
            )
        else:
            return jsonify(
                {
                    "success": False,
                    "message": f"Could not extract {article} from the image",
                }
            ), 400

    except Exception as e:
        return jsonify({"success": False, "error": f"Processing failed: {str(e)}"}), 500

    finally:
        # Clean up temporary file
        if temp_path.exists():
            temp_path.unlink()


@app.route("/download/<filename>", methods=["GET"])
def download_file(filename: str):
    """
    Download a processed image file.

    Args:
        filename: Name of the file to download

    Returns:
        The requested file or 404 if not found
    """
    file_path = OUTPUT_FOLDER / filename
    if file_path.exists():
        return send_file(file_path, as_attachment=True)
    else:
        return jsonify({"error": "File not found"}), 404


@app.route("/images/<filename>", methods=["GET"])
def serve_image(filename: str):
    """
    Serve processed images for display in the frontend.

    Args:
        filename: Name of the image file to serve

    Returns:
        The requested image file or 404 if not found
    """
    file_path = OUTPUT_FOLDER / filename
    if file_path.exists():
        return send_file(file_path, mimetype="image/png")
    else:
        return jsonify({"error": "File not found"}), 404


@app.route("/list-processed", methods=["GET"])
def list_processed_files() -> dict:
    """
    List all processed image files from the database.

    Returns:
        JSON response with list of processed files including metadata
    """
    images = db.get_all_images()

    files = []
    for image in images:
        files.append(
            {
                "id": image["id"],
                "filename": image["filename"],
                "download_url": f"/download/{image['filename']}",
                "image_url": f"/images/{image['filename']}",
                "description": image["description"],
                "categories": [cat["name"] for cat in image["categories"]],
                "tags": [tag["name"] for tag in image["tags"]],
                "created": image["created_at"],
                "updated": image["updated_at"],
            }
        )

    return jsonify({"files": files, "count": len(files)})


@app.route("/outfits/<filename>", methods=["GET"])
def serve_outfit(filename: str):
    """
    Serve outfit images for display in the frontend.

    Args:
        filename: Name of the outfit file to serve

    Returns:
        The requested outfit file or 404 if not found
    """
    file_path = OUTFITS_FOLDER / filename
    if file_path.exists():
        return send_file(file_path, mimetype="image/png")
    else:
        return jsonify({"error": "Outfit file not found"}), 404


@app.route("/download-outfit/<filename>", methods=["GET"])
def download_outfit(filename: str):
    """
    Download an outfit file.

    Args:
        filename: Name of the outfit file to download

    Returns:
        The requested outfit file or 404 if not found
    """
    file_path = OUTFITS_FOLDER / filename
    if file_path.exists():
        return send_file(file_path, as_attachment=True)
    else:
        return jsonify({"error": "Outfit file not found"}), 404


@app.route("/list-outfits", methods=["GET"])
def list_outfits() -> dict:
    """
    List all outfit files from the database.

    Returns:
        JSON response with list of outfits including metadata
    """
    outfits = db.get_all_outfits()

    outfit_list = []
    for outfit in outfits:
        outfit_list.append(
            {
                "id": outfit["id"],
                "filename": outfit["filename"],
                "download_url": f"/download-outfit/{outfit['filename']}",
                "outfit_url": f"/outfits/{outfit['filename']}",
                "description": outfit["description"],
                "created": outfit["created_at"],
                "updated": outfit["updated_at"],
                "items": [
                    {
                        "id": item["id"],
                        "filename": item["filename"],
                        "image_url": f"/images/{item['filename']}",
                    }
                    for item in outfit["items"]
                ],
            }
        )

    return jsonify({"outfits": outfit_list, "count": len(outfit_list)})


@app.route("/generate-outfit", methods=["POST"])
def generate_outfit() -> dict:
    """
    Generate a complete outfit from selected clothing items.

    Expected JSON data:
        - image_ids: List of image IDs to include in the outfit

    Returns:
        JSON response with outfit generation results
    """
    try:
        data = request.get_json()
        if not data or "image_ids" not in data:
            return jsonify({"success": False, "error": "No image IDs provided"}), 400

        image_ids = data["image_ids"]
        if not isinstance(image_ids, list) or len(image_ids) == 0:
            return jsonify(
                {"success": False, "error": "Invalid image IDs provided"}
            ), 400

        # Get image details from database
        images = []
        image_paths = []
        categories = []

        for image_id in image_ids:
            image_data = db.get_image(image_id)
            if not image_data:
                return jsonify(
                    {"success": False, "error": f"Image with ID {image_id} not found"}
                ), 404

            images.append(image_data)
            image_paths.append(Path(image_data["file_path"]))

            # Collect categories for the prompt
            for category in image_data["categories"]:
                if category["name"] not in categories:
                    categories.append(category["name"])

        if len(images) < 2:
            return jsonify(
                {
                    "success": False,
                    "error": "Please select at least 2 clothing items to generate an outfit",
                }
            ), 400

        # Generate the outfit
        outfit_path = generate_outfit_with_ai(image_paths, categories)

        if outfit_path and outfit_path.exists():
            # Save outfit to outfits table
            outfit_id = db.add_outfit(
                filename=outfit_path.name,
                file_path=str(outfit_path),
                description=f"Generated outfit from {len(images)} items: {', '.join(categories)}",
            )

            # Link clothing items to the outfit
            for image_data in images:
                db.add_item_to_outfit(outfit_id, image_data["id"])

            return jsonify(
                {
                    "success": True,
                    "message": f"Successfully generated outfit from {len(images)} items",
                    "outfit_url": f"/outfits/{outfit_path.name}",
                    "download_url": f"/download-outfit/{outfit_path.name}",
                    "outfit_id": outfit_id,
                    "categories": categories,
                }
            )
        else:
            return jsonify(
                {
                    "success": False,
                    "error": "Failed to generate outfit. Please try again with different items.",
                }
            ), 500

    except Exception as e:
        logging.error(f"Error generating outfit: {e}")
        return jsonify(
            {"success": False, "error": f"Outfit generation failed: {str(e)}"}
        ), 500


if __name__ == "__main__":
    # Run the Flask app
    debug_mode = os.getenv("FLASK_ENV") != "production"
    app.run(debug=debug_mode, host="0.0.0.0", port=5000)
